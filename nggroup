#!/usr/bin/env bash

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

. "$DIR/config"

# if we're in production, we need root - have to access $HTPASS_DIR
if [ -n "$_IN_PRODUCTION" ] && [ "$(id -u)" != "0" ];
then
    echo "Error; Must run as root."
    exit 1
fi

# make sure we've got all our directories available
for directory in $HTPASS_DIR $SITES_DIR $USER_DIR $GROUP_DIR;
do
    mkdir -p "$directory"
done

site () {
    local site_file
    site_file=$(printf "$SITES_DIR_FORMAT" "$2")
    case $1 in
	siteadd )
	    if [ -e "$site_file" ];
	    then
		echo "Error: Site already exists."
		exit 1
	    fi
	    touch "$site_file"
	    ;;
	sitedel )
	    if [ ! -e "$site_file" ];
	    then
		echo "Error: Site does not exist."
		exit 1
	    fi
	    rm "$site_file"
	    ;;
	sitemod )
	    mod_funct "$site_file" "$3" "$4" "Site"
	    ;;
    esac
}

user () {
    local rules_file
    local generated_file
    rules_file=$(printf "$USER_DIR_FORMAT" "$2")
    generated_file=$(printf "$USER_COMPLETE_DIR_FORMAT" "$2")

    case $1 in
	useradd )
	    if [ -e "$rules_file" ];
	    then
		echo "Error: user already exists."
		exit 1
	    fi

	    # contents=$(htpasswd -nb "$2" "$3")

	    echo "$2$USER_DIR_FORMAT_DELIM$3$USER_DIR_FORMAT_DELIM$4" > "$rules_file"
	    ;;

	# TODO: make a global?
	userdel )
	    if [ ! -e "$rules_file" ];
	    then
		echo "Error: User does not exist."
		exit 1
	    fi

	    user_format_regex="^$(printf \"$USER_RULE_FORMAT\" $2)\$"

	    for file_to_remove_from in $(grep -lR "$user_format_regex" "$GROUP_DIR" "$SITES_DIR");
	    do
		sed -i "/$user_format_regex/d" "$file_to_remove_from"
	    done

	    if [ -e "$generated_file" ];
	    then
		rm "$generated_file"
	    fi

	    rm "$rules_file" 
    esac
}

group () {
    local group_file
    group_file=$(printf "$GROUP_DIR_FORMAT" "$2")
    
    case $1 in
	groupadd )
	    if [ -e "$group_file" ];
	    then
		echo "Error: group already exists."
		exit 1
	    fi

	    touch "$group_file"
	    ;;
	groupdel )
	    if [ ! -e "$group_file" ];
	    then
		echo "Error: Group does not exist."
		exit 1
	    fi

	    group_format_regex="^$(printf \"$GROUP_RULE_FORMAT\" $2)\$"

	    for file_to_remove_from in $(grep -lR $group_format_regex "$GROUP_DIR" "$SITES_DIR");
	    do
		sed -i "/$group_format_regex/d" "$file_to_remove_from"
	    done

	    rm "$group_file"
	    ;;
	groupmod )
	    mod_funct "$group_file" "$3" "$4" "Group"
	    ;;
    esac
}

# a shared function for performing (site|group)mod
mod_funct () {
    if [ ! -e "$1" ];
    then
	printf "Error: %s does not exist\n" "$4"
	exit 1
    fi

    local context
    local context_file
    local context_dir_format
    local context_rule_format
    local context_friendly
    local context_in_file_search

    context=$(echo "$3" | cut -c 2-)

    case $3 in
	u* )
	    context_dir_format=$USER_DIR_FORMAT
	    context_rule_format=$USER_RULE_FORMAT
	    context_friendly=User
	    context_in_file_search=$context
	    ;;
	g* )
	    context_dir_format=$GROUP_DIR_FORMAT
	    context_rule_format=$GROUP_RULE_FORMAT
	    context_friendly=Group
	    context_in_file_search="@$context"
	    ;;
    esac

    context_file=$(printf "$context_dir_format" "$context")
    context_insert=$(printf "$context_rule_format" "$context")

    if [ ! -e "$context_file" ];
    then
	printf "Error: %s does not exist.\n" "$context_friendly"
	exit 1
    fi

    # TODO: make sure all greps are strict!
    grep "^$context_in_file_search$" "$1" > /dev/null
    context_in_file=$?

    case $2 in
	a )
	    if [ 0 -eq $context_in_file ];
	    then
		printf "Error: %s is already part of the group.\n" $context_friendly
		exit 1
	    else
		echo "$context_insert" >> "$1"
	    fi
	    ;;
	d )
	    if [ 0 -eq "$context_in_file" ];
	    then
		sed -i "/^$context_insert$/d" "$1"
	    else
		printf "Error: %s does not exist in the group.\n" $context_friendly
		exit 1
	    fi
	    ;;
    esac

}

generate_sites () {
    # TODO as separate function - `generate users`, `generate sites` etc
    for user_rule_file in $USER_DIR/.*.rules;
    do
	username=$(cat $user_rule_file | cut -f1 -d$USER_DIR_FORMAT_DELIM)
	user_out_file=$(printf "$USER_COMPLETE_DIR_FORMAT" "$username")
	user_password=$(cat $user_rule_file | cut -f2 -d$USER_DIR_FORMAT_DELIM)
	echo $(htpasswd -nb "$username" "$user_password" ) > $user_out_file
    done

    for rule_file in $SITES_DIR/.*.rules;
    do
	local site_file_insert
	local site_name
	local site_file_path

	site_name=$(echo "$rule_file"  | sed 's/.*\.\(.*\)\..*/\1/g')
	site_file_path=$(printf "$SITES_COMPLETE_DIR_FORMAT" "$site_name")
	site_file_tmp_path=$site_file_path.tmp

	[ -e "$site_file_tmp_path" ] && rm "$site_file_tmp_path"

	while read -r line
	do
	    local user_list

	    case $(echo "$line" | cut -c 1) in
		@ )
		    group_name=$(echo "$line" | cut -c 2-)
		    group_file=$(printf "$GROUP_DIR_FORMAT" "$group_name")
		    user_list=$(cat "$group_file")
		    echo "# @$group_name" >> "$site_file_tmp_path"
		    ;;
		* )
		    echo "# $line" >> "$site_file_tmp_path"
		    user_list=$line
		    ;;
	    esac

	    for user in $user_list
	    do
		local user_path
		user_path=$(printf "$USER_COMPLETE_DIR_FORMAT" "$user")
		cat "$user_path" >> "$site_file_tmp_path"
	    done

	done < "$rule_file"

	# if we don't have a previous version, or if they're different,
	#  we prioritise the newly generated file
	if [ ! -e "$site_file_path" ] || ! diff "$site_file_path" "$site_file_tmp_path" > /dev/null;
	then
	    mv "$site_file_tmp_path" "$site_file_path"
	fi
    done

}

# our main processing
case $1 in
    site* )
	site "$@"
	;;

    user* )
	user "$@"
	;;

    group* )
	group "$@"
	;;
    generate )
	generate_sites
	;;
esac

