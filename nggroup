#!/bin/bash

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

. $DIR/config

# if we're in production, we need root - have to access $HTPASS_DIR
if [ -n "$_IN_PRODUCTION" ] && [ "$(id -u)" != "0" ];
then
    echo "Error; Must run as root."
    exit 1
fi

# make sure we've got all our directories available
for directory in $HTPASS_DIR $SITES_DIR $USER_DIR $GROUP_DIR;
do
    mkdir -p $directory
done

site () {
    local site_file
    site_file=$(printf $SITES_DIR_FORMAT $2)
    case $1 in
	siteadd )
	    if [ -e $site_file ];
	    then
		echo "Error: Site already exists."
		exit 1
	    fi
	    touch $site_file
	    ;;
	sitedel )
	    if [ ! -e $site_file ];
	    then
		echo "Error: Site does not exist."
		exit 1
	    fi
	    rm $site_file
	    ;;
	sitemod )
	    mod_funct $site_file $3 $4 "Site"
	    ;;
    esac
}

user () {
    local file
    file=$(printf $USER_DIR_FORMAT $2)
    
    case $1 in
	useradd )
	    contents=$(htpasswd -nb $2 $3)
	    if [ -e $file ];
	    then
		echo "Error: user already exists."
		exit 1
	    fi

	    echo $contents > $file
	    ;;
	userdel )
	    if [ ! -e $file ];
	    then
		echo "Error: User does not exist."
		exit 1
	    fi

	    for file_to_remove_from in $(grep -lR "^$2\$" $GROUP_DIR $SITES_DIR);
	    do
		sed -i "/^$2\$/d" $file_to_remove_from
	    done

	    rm $file
    esac
}

group () {
    local group_file
    group_file=$(printf $GROUP_DIR_FORMAT $2)
    
    case $1 in
	groupadd )
	    if [ -e $group_file ];
	    then
		echo "Error: group already exists."
		exit 1
	    fi

	    touch $group_file
	    ;;
	groupdel )
	    if [ ! -e $group_file ];
	    then
		echo "Error: Group does not exist."
		exit 1
	    fi

	    for file_to_remove_from in $(grep -lR "^@$2\$" $GROUP_DIR $SITES_DIR);
	    do
		sed -i "/^@$2\$/d" $file_to_remove_from
	    done

	    rm $group_file
	    ;;
	groupmod )
	    mod_funct $group_file $3 $4 "Group"
	    ;;
    esac
}

# a shared function for performing (site|group)mod
mod_funct () {
    if [ ! -e $1 ];
    then
	printf "Error: %s does not exist\n" $4
	exit 1
    fi

    local context
    local context_file
    local context_dir_format
    local context_rule_format
    local context_friendly
    local context_in_file_search

    context=$(echo $3 | cut -c 2-)

    case $3 in
	u* )
	    context_dir_format=$USER_DIR_FORMAT
	    context_rule_format=$USER_RULE_FORMAT
	    context_friendly=User
	    context_in_file_search=$context
	    ;;
	g* )
	    context_dir_format=$GROUP_DIR_FORMAT
	    context_rule_format=$GROUP_RULE_FORMAT
	    context_friendly=Group
	    context_in_file_search="@$context"
	    ;;
    esac

    context_file=$(printf $context_dir_format $context)
    context_insert=$(printf $context_rule_format $context)

    if [ ! -e $context_file ];
    then
	printf "Error: %s does not exist.\n" $context_friendly
	exit 1
    fi

    # TODO: make sure all greps are strict!
    grep "^$context_in_file_search$" $1 > /dev/null
    context_in_file=$?

    case $2 in
	a )
	    if [ 0 -eq $context_in_file ];
	    then
		printf "Error: %s is already part of the group.\n" $context_friendly
		exit 1
	    else
		echo $context_insert >> $1
	    fi
	    ;;
	d )
	    if [ 0 -eq $context_in_file ];
	    then
		sed -i /^$context_insert$/d $1
	    else
		printf "Error: %s does not exist in the group.\n" $context_friendly
		exit 1
	    fi
	    ;;
    esac

}

generate_sites () {
    for rule_file in $SITES_DIR/.*.rules;
    do
	local site_file_insert
	local site_name
	local site_file_path

	site_name=$(echo $rule_file  | sed 's/.*\.\(.*\)\..*/\1/g')
	site_file_path=$(printf $SITES_COMPLETE_DIR_FORMAT $site_name)
	site_file_tmp_path=$site_file_path.tmp

	[ -e $site_file_tmp_path ] && rm $site_file_tmp_path

	while read -r line
	do
	    local user_list

	    case $(echo $line | cut -c 1) in
		@ )
		    group_name=$(echo $line | cut -c 2-)
		    user_list=$(cat $GROUP_DIR/$group_name)
		    echo "# @$group_name" >> $site_file_tmp_path
		    ;;
		* )
		    echo "# $line" >> $site_file_tmp_path
		    user_list=$line
		    ;;
	    esac

	    for user in $user_list
	    do
		cat $USER_DIR/$user >> $site_file_tmp_path
	    done

	done < $rule_file

	# if we don't have a previous version, or if they're different,
	#  we prioritise the newly generated file
	if [ ! -e $site_file_path ] || ! diff $site_file_path $site_file_tmp_path > /dev/null;
	then
	    mv $site_file_tmp_path $site_file_path
	fi
    done

}

# our main processing
case $1 in
    site* )
	site $@
	;;

    user* )
	user $@
	;;

    group* )
	group $@
	;;
    generate )
	generate_sites
	;;
esac

