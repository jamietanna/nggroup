#!/usr/bin/env bash

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

. "$DIR/config"

# if we're in production, we need root - have to access $HTPASS_DIR
if [ -n "$_IN_PRODUCTION" ] && [ "$(id -u)" != "0" ];
then
	error "Must run as root."
fi

# make sure we've got all our directories available
for directory in $HTPASS_DIR $SITES_DIR $USER_DIR $GROUP_DIR;
do
	mkdir -p "$directory"
done

site () {
	local site_file
	site_file=$(printf "$SITES_DIR_FORMAT" "$2")
	case $1 in
	siteadd )
		[ -e "$site_file" ] && error "Site already exists."
		touch "$site_file"
		;;
	sitedel )
		[ ! -e "$site_file" ] && error "Site does not exist."
		rm "$site_file"
		;;
	sitemod )
		mod_funct "$site_file" "$3" "Site"
		;;
	esac
}

user () {
	local rules_file
	local generated_file
	rules_file=$(printf "$USER_DIR_FORMAT" "$2")
	generated_file=$(printf "$USER_COMPLETE_DIR_FORMAT" "$2")

	case $1 in
	useradd )
		[ -e "$rules_file" ] && error "user already exists."

		any_errors=false

		isset "$2" "Username is blank" || any_errors=true
		isset "$3" "Password is blank" || any_errors=true
		isset "$4" "Email is blank" || any_errors=true
		isset "$5" "Name is blank" || any_errors=true

		# username, password, email, name
		if $any_errors;
		then
			error "Please fix the above errors"
		else
			csv "$2" "$3" "$4" "$5" > "$rules_file"
		fi
		;;

	# TODO: make a global?
	userdel )
		[ ! -e "$rules_file" ] && error "User does not exist."

		user_format_regex="^$(printf \"$USER_RULE_FORMAT\" $2)\$"

		for file_to_remove_from in $(grep -lR "$user_format_regex" "$GROUP_DIR" "$SITES_DIR");
		do
			sed -i "/$user_format_regex/d" "$file_to_remove_from"
		done

		# delete, whether it exists or not
		rm -f "$generated_file"

		rm "$rules_file"
	esac
}

group () {
	local group_file
	group_file=$(printf "$GROUP_DIR_FORMAT" "$2")

	case $1 in
	groupadd )
		[ -e "$group_file" ] && error "Group already exists."
		touch "$group_file"
		;;
	groupdel )
		[ ! -e "$group_file" ] && error "Group does not exist."
		group_format_regex="^$(printf \"$GROUP_RULE_FORMAT\" $2)\$"

		for file_to_remove_from in $(grep -lR $group_format_regex "$GROUP_DIR" "$SITES_DIR");
		do
			sed -i "/$group_format_regex/d" "$file_to_remove_from"
		done

		rm "$group_file"
		;;
	groupmod )
		mod_funct "$group_file" "$3" "Group"
		;;
	esac
}

# a shared function for performing (site|group)mod
mod_funct () {
	local is_group
	local context
	local context_file
	local context_dir_format
	local context_rule_format
	local context_friendly
	local context_in_file_search

	if [ "$(echo $2 | cut -c 2)" == "@" ];
	then
		is_group=true
		context="$(echo $2 | cut -c 3-)"
	else
		is_group=false
		context="$(echo $2 | cut -c 2-)"
	fi

	if $is_group && [ "$context" == "all" ];
	then
		for user_path in $(ls $USER_DIR/*);
		do
			echo $(basename $user_path) >> "$1"
		done
		return
	fi


	[ ! -e "$1" ] && error $(printf "%s does not exist\n" "$3")

	context_friendly=$3

	if $is_group;
	then
		context_dir_format=$GROUP_DIR_FORMAT
		context_rule_format=$GROUP_RULE_FORMAT
		context_in_file_search="@$context"
	else
		context_dir_format=$USER_DIR_FORMAT
		context_rule_format=$USER_RULE_FORMAT
		context_in_file_search=$context
	fi

	context_file=$(printf "$context_dir_format" "$context")
	context_insert=$(printf "$context_rule_format" "$context")

	[ ! -e "$context_file" ] && error $(printf "%s does not exist.\n" "$context_friendly")

	# TODO: make sure all greps are strict!
	grep "^$context_in_file_search$" "$1" > /dev/null
	context_in_file=$?

	if [ "$(echo "$2" | cut -c 1)" == "+" ];
	then
		if [ 0 -eq $context_in_file ];
		then
			error $(printf "%s is already part of the group.\n" $context_friendly)
		else
			echo "$context_insert" >> "$1"
		fi
	else
		if [ 0 -eq "$context_in_file" ];
		then
			sed -i "/^$context_insert$/d" "$1"
		else
			error $(printf "%s does not exist in the group.\n" $context_friendly)
		fi
	fi

}

generate () {
	case "$1" in
	users )
		generate_users
		;;
	sites )
		generate_sites
		;;
	* )
		generate "users"
		generate "sites"
		;;
	esac
}

generate_users () {
	for user_rule_file in $USER_DIR/.*.rules;
	do
		username=$(cat $user_rule_file | cut -f1 -d,)
		user_out_file=$(printf "$USER_COMPLETE_DIR_FORMAT" "$username")
		user_password=$(cat $user_rule_file | cut -f2 -d,)
		echo $(htpasswd -nb "$username" "$user_password" ) > $user_out_file
	done
}

generate_sites () {
	for rule_file in $SITES_DIR/.*.rules;
	do
		local site_file_insert
		local site_name
		local site_file_path

		site_name=$(echo "$rule_file"  | sed 's/.*\.\(.*\)\..*/\1/g')
		site_file_path=$(printf "$SITES_COMPLETE_DIR_FORMAT" "$site_name")
		site_file_tmp_path=$site_file_path.tmp

		rm -f "$site_file_tmp_path"
		touch "$site_file_tmp_path"

		all_groups=""
		loose_users=""

		while read -r line
		do
			if [ "$(echo "$line" | cut -c 1)" == "@" ];
			then
				all_groups+="$line "
			else
				loose_users+="$line "
			fi
	
			local user_list

			case $(echo "$line" | cut -c 1) in
				@ )
					group_name=$(echo "$line" | cut -c 2-)
					group_file=$(printf "$GROUP_DIR_FORMAT" "$group_name")
					member_list=$(cat "$group_file")
					echo "# @$group_name" >> "$site_file_tmp_path"
					;;
				* )
					echo "# $line" >> "$site_file_tmp_path"
					member_list=$line
					;;
			esac

			# TODO: see README.md

			for member in $member_list
			do
				if [ "$(echo $member | cut -c 1)" == "@" ];
				then
					group=$(echo $member | cut -c 2-)
					# need to have the group file grabbed here
				else
					user=$member
					local user_path
					user_path=$(printf "$USER_COMPLETE_DIR_FORMAT" "$user")
					cat "$user_path" >> "$site_file_tmp_path"
				fi

			done

		done < "$rule_file"

		expanded_users="$loose_users"
		groups_to_expand="$all_groups"
		groups_expanded=""

		while true;
		do
			group=$(echo "$groups_to_expand" | cut -f1 -d" ")
			groups_to_expand=$(echo "$groups_to_expand" | cut -f2- -d" ")

			group_name=$(echo $group | cut -c 2-)
			group_file=$(printf "$GROUP_DIR_FORMAT" "$group_name")
			member_list=$(cat "$group_file")

			for member in $member_list;
			do
				if [ "$(echo $member | cut -c 1)" == "@" ];
				then
					if [[ ! "$groups_expanded" =~ "$member " ]];
					then
						groups_to_expand+="$member "
					fi
				else
					expanded_users+="$member "
				fi
			done

			groups_expanded+="$group "

			if [ -z "$groups_to_expand" ] || [ "$groups_to_expand" == " " ] || [ "$group" == "$groups_to_expand" ];
			then
				break
			fi
		done

		final_users=$(echo "$expanded_users" | sed 's/ /\n/g' | sort | uniq)
		for user in $final_users;
		do
			user_path=$(printf "$USER_COMPLETE_DIR_FORMAT" "$user")
			cat "$user_path" >> "$site_file_tmp_path"
		done

		# if we don't have a previous version, or if they're different,
		#  we prioritise the newly generated file
		if [ ! -e "$site_file_path" ] || ! diff "$site_file_path" "$site_file_tmp_path" > /dev/null;
		then
			mv "$site_file_tmp_path" "$site_file_path"
		fi
	done
}

# our main processing
case $1 in
	site* )
		site "$@"
		;;

	user* )
		user "$@"
		;;

	group* )
		group "$@"
		;;

	generate* )
		generate "$2"
		;;

esac
