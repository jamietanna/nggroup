#!/usr/bin/env bash

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

. "$DIR/config"

site () {
	local site_file=$(get_site_rule_path "$2")
	case "$1" in
	siteadd )
		[ -e "$site_file" ] && die "Site already exists."
		touch "$site_file"
		;;
	sitedel )
		[ ! -e "$site_file" ] && die "Site does not exist."
		rm "$site_file"
		;;
	sitemod )
		mod_funct "$site_file" "$3" "Site"
		;;
	esac
}

user () {
	local rules_file
	local generated_file
	rules_file=$(get_user_rule_path "$2")
	generated_file=$(get_user_complete_path "$2")

	case $1 in
	useradd )
		[ -e "$rules_file" ] && die "user already exists."

		any_errors=false
		isset "$2" "Username is blank" || any_errors=true
		isset "$3" "Password is blank" || any_errors=true
		isset "$4" "Email is blank" || any_errors=true
		isset "$5" "Name is blank" || any_errors=true

		# username, password, email, name
		if $any_errors;
		then
			die "Please fix the above errors"
		else
			password=$(htpasswd -nb "$2" "$3" | cut -f2 -d:)
			csv "$2" "$password" "$4" "$5" > "$rules_file"
		fi
		;;

	# TODO: make a global?
	userdel )
		[ ! -e "$rules_file" ] && die "User does not exist."

		user_format_regex="^$(get_user_rule_entry \"$2\")$"

		for file_to_remove_from in $(grep -lR "$user_format_regex" "$GROUP_DIR" "$SITES_DIR");
		do
			sed -i "/$user_format_regex/d" "$file_to_remove_from"
		done

		# delete, whether it exists or not
		rm -f "$generated_file"

		rm "$rules_file"
	esac
}

group () {
	local group_file
	group_file=$(get_group_rules_path "$2")

	case $1 in
	groupadd )
		[ -e "$group_file" ] && die "Group already exists."
		touch "$group_file"
		;;
	groupdel )
		[ ! -e "$group_file" ] && die "Group does not exist."
		group_format_regex="^$(get_group_rule_entry \"$2\")$"

		for file_to_remove_from in $(grep -lR $group_format_regex "$GROUP_DIR" "$SITES_DIR");
		do
			sed -i "/$group_format_regex/d" "$file_to_remove_from"
		done

		rm "$group_file"
		;;
	groupmod )
		mod_funct "$group_file" "$3" "Group"
		;;
	esac
}

# a shared function for performing (site|group)mod
mod_funct () {
	local is_group
	local context
	local context_friendly=$3

	if [ "$(echo $2 | cut -c 2)" == "@" ];
	then
		is_group=true
		context="$(echo $2 | cut -c 3-)"
	else
		is_group=false
		context="$(echo $2 | cut -c 2-)"
	fi

	if $is_group && [ "$context" == "all" ];
	then
		for user_path in $(ls $USER_DIR/*);
		do
			echo $(basename $user_path) >> "$1"
		done
		return
	fi

	[ ! -e "$1" ] && die $(printf "%s does not exist\n" "$3")

	local context_dir_format
	local context_rule_format
	local context_file
	local context_insert

	if $is_group;
	then
		context_file=$(get_group_rules_path $context)
		context_insert=$(get_group_rule_entry $context)
	else
		context_file=$(get_user_rule_path $context)
		context_insert=$(get_user_rule_entry $context)
	fi

	[ ! -e "$context_file" ] && die $(printf "%s does not exist.\n" "$context_friendly")

	local context_in_file=true
	grep "^$context_insert$" "$1" > /dev/null || context_in_file=false

	if [ "$(echo "$2" | cut -c 1)" == "+" ];
	then
		if $context_in_file;
		then
			die $(printf "%s is already part of the group.\n" $context_friendly)
		else
			echo "$context_insert" >> "$1"
		fi
	else
		if $context_in_file;
		then
			sed -i "/^$context_insert$/d" "$1"
		else
			die $(printf "%s does not exist in the group.\n" $context_friendly)
		fi
	fi
}

generate () {
	case "$1" in
	users )
		generate_users
		;;
	sites )
		generate_sites
		;;
	* )
		generate "users"
		generate "sites"
		;;
	esac
}

generate_users () {
	for user_rule_file in $USER_DIR/.*.rules;
	do
		username=$(cat $user_rule_file | cut -f1 -d,)
		user_out_file=$(get_user_complete_path "$username")
		user_password=$(cat $user_rule_file | cut -f2 -d,)
		echo "$username:$user_password" > $user_out_file
	done
}

generate_sites () {
	for rule_file in $SITES_DIR/.*.rules;
	do
		local site_file_insert
		local site_name
		local site_file_path

		site_name=$(echo "$rule_file"  | sed 's/.*\.\(.*\)\..*/\1/g')
		site_file_path=$(get_site_complete_path "$site_name")
		site_file_tmp_path=$site_file_path.tmp

		rm -f "$site_file_tmp_path"
		touch "$site_file_tmp_path"

		local expanded_users=""
		local groups_to_expand=""
		local groups_expanded=""

		while read -r line
		do
			if [ "$(echo "$line" | cut -c 1)" == "@" ];
			then
				groups_to_expand+="$line "
			else
				expanded_users+="$line "
			fi
		done < "$rule_file"

		while true;
		do
			if [ -z "$groups_to_expand" ] || [ "$groups_to_expand" == " " ] || [ "$group" == "$groups_to_expand" ];
			then
				break
			fi
			# TODO do this with shift/ for?
			local group=$(echo "$groups_to_expand" | cut -f1 -d" ")
			groups_to_expand=$(echo "$groups_to_expand" | cut -f2- -d" ")

			local group_name=$(echo $group | cut -c 2-)
			local group_file=$(get_group_rules_path "$group_name")
			local member_list=$(cat "$group_file")

			for member in $member_list;
			do
				if [ "$(echo $member | cut -c 1)" == "@" ];
				then
					if [[ ! "$groups_expanded" =~ "$member " ]];
					then
						groups_to_expand+="$member "
					fi
				else
					expanded_users+="$member "
				fi
			done

			groups_expanded+="$group "
		done

		final_users=$(echo "$expanded_users" | sed 's/ /\n/g' | sort | uniq)
		for user in $final_users;
		do
			user_path=$(get_user_complete_path "$user")
			cat "$user_path" >> "$site_file_tmp_path"
		done

		# if we don't have a previous version, or if they're different,
		#  we prioritise the newly generated file
		if [ ! -e "$site_file_path" ] || ! diff "$site_file_path" "$site_file_tmp_path" > /dev/null;
		then
			mv "$site_file_tmp_path" "$site_file_path"
		fi
	done
}

# our main processing
case $1 in
	site* )
		site "$@"
		;;

	user* )
		user "$@"
		;;

	group* )
		group "$@"
		;;

	generate* )
		generate "$2"
		;;

esac
